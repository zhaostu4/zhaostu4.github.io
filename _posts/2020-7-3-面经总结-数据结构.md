---
layout:     post
title:      面经总结 数据结构
subtitle:   面经总结 数据结构
date:       2019/12/15
author:     zhaostu4
header-img: img/post-bg-ios10.jpg
catalog: true
tags:
    - 面经总结
    - 数据结构
    - 面经总结 数据结构
---

>> T:2019/12/15  W:零 10:15:24

# 二叉树
## 搜索树
- 概念
- 特点
- 插入
- 删除
## 平衡树
- 概念
- 特点
- 插入
- 删除
## 红黑树
- 概念
- 特点
- 插入
- 删除

# 多叉树
## B树
- 概念
- 特点
- 插入
- 删除

## 平衡二叉树
- 画平衡二叉树建立过程。
    - 二叉查找树
        - 如果插入的数据比当前的节点大，并且节点的右子树为空，那么直接把当前的值插入到当前右子节点，如果不为空的话，那么递归查找右子树的位置，
        - 同理如果插入的数据比节点小，并且节点的左子树为空，那么直接把值插入到节点的左节点，如果不为空，递归遍历节点的左子树，寻找插入的位置
    - 平衡调转: [平衡二叉树(树的旋转)](https://blog.csdn.net/qq_24336773/article/details/81712866)
        - LL型调整: A的左孩子B, B的左孩子插入导致不平衡
            - B调整为根
            - A调整为B的右节点
            - 然后将BR->AL
        - RR型调整: A的右孩子B, B的右孩子插入导致不平衡
            - 把B调转为根结点
            - 把A调转为B的左节点
            - 然后将BL->AR
        - LR型调整: A的左孩子B, B的右孩子插入, C为新插入节点
            - 把C调转为新根
            - 把A调整为C的右根, B调整为C的左节点
            - CL->BR, CR->AL
        - RL型调整:
            - 把C调转为新根
            - 把A调整为C的左根, B调整为C的右节点
            - CL->AR, CR->BL


## 红黑树
- 红黑树的性质：
	- 每个节点或是红色的，或是黑色的。
	- 根节点是黑色的。
	- 每个叶节点`(NULL)`是黑色的。
	- 如果一个节点是红色的，则它的两个孩子节点都是黑色的。
	- 对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。
- 画红黑树构造过程。
    - 首先搜素树插入,默认为红色
    - 然后红黑树调整
        - 此节点作为根节点或, 直接把本节点变成黑色
        - 如果被插节点为黑色, 不用做
        - 然后就是被插节点为红色:
            - 叔叔节点是红色
                - (01) 将“父节点”设为黑色。
                - (02) 将“叔叔节点”设为黑色。
                - (03) 将“祖父节点”设为“红色”。
                - (04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。
            - 叔叔节点是黑色，且当前节点是其父节点的右孩子
                - (01) 将“父节点”作为“新的当前节点”。
                - (02) 以“新的当前节点”为支点进行左旋。
                - (03) 继续对“当前节点”进行操作。
            - 叔叔节点是黑色，且当前节点是其父节点的左孩子	
                - (01) 将“父节点”设为“黑色”。
                - (02) 将“祖父节点”设为“红色”。
                - (03) 以“祖父节点”为支点进行右旋。

## B+树
- `BTree`: 对于`m`阶`BTree`
    - 每个节点最多有`m`个孩子节点
    - 除了根结点和叶子结点,其他节点至少有`ceil(m/2)`个节点
    - 非叶子结点的根节点至少有2个孩子节点
    - 所有叶子结点都位于同一层,且不包含其他关键节点信息
    - 所有非终端节点至少包括的关键字个数应该大于等于`ceil(m/2)`,小于等于`m`
    - 这些关键字升序排列
    - 子树的所有关键字小于对应父节点关键字, 但是大于前一个兄弟节点的关键字
- `B+Tree`相对于`B-Tree`有几点不同：
    - 非叶子节点只存储键值信息。
    - 数据记录都存放在叶子节点中。
    - 所有叶子节点之间都有一个链指针。

---
- 总结：
	- BTree： m阶
		- 节点数量
		- 关键字数量
		- 顺序问题
		- 叶子节点

- 参考: [B+树总结](https://www.jianshu.com/p/71700a464e97)
- 概念
    - 有k个子结点的结点必然有k个关键码(关键码为子树的最大值)
    - 非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中
    - 树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录
- 特点: 它解决了B树遍历过慢, 以及数据和节点绑定到一起的问题
- 插入:
    - (1) 若为空树，那么创建一个节点并将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。
    - (2) 针对`叶子类型结点`：根据key值找到叶子结点，向这个叶子结点插入记录。
        - 插入后，
        - 若当前结点key的个数小于等于m-1(5-1=4)，则插入结束。
        - 否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2(2)个记录，右结点包含剩下的记录, 更新父节点键值。
        - 执行第3步。
    - (3) 针对`索引类型结点`：(增加一层)
        - 若当前结点key的个数小于等于m-1(4)，则插入结束。
        - 否则，将这个索引类型结点分裂成两个索引结点，
            - 左索引结点包含前(m-1)/2个key(2)，
            - 右结点包含m-(m-1)/2个key(3个)，
            - 将第m/2个key进位到父结点中，进位到父结点的key左孩子指向左结点，进位到父结点的key右孩子指向右结点。
        - 将当前结点的指针指向父结点，然后重复第3步。
- 删除
    - (1) 删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m/2) – 1（>=2），删除操作结束，否则执行第2步。
    - (2) 若结点的key的个数小于Math.ceil(m/2) – 1（<2），且兄弟结点key有富余（大于Math.ceil(m/2)– 1）（>2），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。
    - (3) 若结点的key的个数小于Math.ceil(m/2) – 1（<2），且兄弟结点中没有富余的key（小于Math.ceil(m/2)– 1），则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key，将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。
    - (4) 若索引结点的key的个数大于等于Math.ceil(m/2) – 1（>=2），则删除操作结束。否则执行第5步。
    - (5) 若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步
    - (6) 当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。

## 排序算法

| 排序算法     | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |
| ------------ | -------------- | -------------- | ---------- | -------- |
| 冒泡排序     | O（n^2）        | O（n^2）        | O（1）     | 是       |
| 选择排序     | O（n^2）        | O（n^2）        | O（1）     | 不是     |
| 直接插入排序 | O（n^2）        | O（n^2）        | O（1）     | 是       |
| 归并排序     | O(nlogn)       | O(nlogn)       | O（n）     | 是       |
| 快速排序     | O(nlogn)       | O（n^2）        | O（logn）  | 不是     |
| 堆排序       | O(nlogn)       | O(nlogn)       | O（1）     | 不是     |
| 希尔排序     | O(nlogn)       | O（n^s）        | O（1）     | 不是     |
| 计数排序     | O(n+k)O        | O(n+k)         | O(n+k)     | 是       |
| 基数排序     | O(N∗M)         | O(N∗M)         | O(M)       | 是       |
    - 参考: [排序算法时间复杂度、空间复杂度、稳定性比较](https://blog.csdn.net/yushiyi6453/article/details/76407640)