---
layout:     post
title:      面经复习 操作系统
subtitle:   面经复习 操作系统
date:       2019/11/28
author:     zhaostu4
header-img: img/post-bg-ios10.jpg
catalog: true
tags:
	- 操作系统
	- 面经复习
	- 面经复习 操作系统
---

>> T:2019/11/28  W:四 17:0:11
[HTML]: @[TOC](面经复习 操作系统)

## 进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的
## 进程间通信的方式：
- 管道, 套接字, 系统IPC(信号,信号量, 消息队列,  共享内存)
## `Linux`虚拟地址空间
- 好处
	- 扩大地址(寻址空间和寻址空间)
	- 独立性更强(方便管理(保护和使用), 方便共享)
	- 实现了虚拟储存技术(配合缺页中断)
- 缺点
	- 慢(转换慢, 缺页慢)
	- 浪费(页不满浪费, 管理结构浪费)
## 操作系统中的程序的内存结构
- 可执行程序中
- 可执行程序加载到内存中成为进程
- 变成进程之后多得:堆(第一次调用时建立), 栈, 映射区
## 操作系统中的缺页中断
- 为什么产生缺页中断
- 缺页中断的产生过程
- 中断的处理过程
## `fork`和`vfork`的区别
## 如何修改文件最大句柄数？
## 并发(concurrency)和并行(parallelism)
## `MySQL`的端口号是多少，如何修改这个端口号
- `mysql 3306`:`show global variables like 'port'`
- 修改配置文件: `/etc/my.conf`

---
- `sqlserver`: 1433
- `PostgreSQL`: 5432
- `oracle`: 1521
- `redis`: 6379
- `DB2`: 5000

## 操作系统中的页表寻址
## 有了进程，为什么还要有线程？
## 单核机器上写多线程程序，是否需要考虑加锁，为什么？
- 
## 线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的
- 线程上下文切换: ID, 线程状态, 寄存器组, 栈	
- sp, pc, eax
## 线程间的同步方式，最好说出具体的系统调用
## 多线程和多进程的不同
## 进程和线程的区别
## 游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？
## `OS`缺页置换算法
## 多进程和多线程的使用场景
## 死锁发生的条件以及如何解决死锁
- 互斥
- 请求与保持
- 不可剥夺
- 循环请求链
---
- 一次性分配
- 不满足则释放
- 顺序取资源	
## 虚拟内存和物理内存怎么对应
- 物理地址和虚拟地址
- 段式内存管理
- 页式内存管理
- 多级页式内存管理
## 操作系统中的结构体对齐，字节对齐
- 对齐原因:两个
- 对齐规则:三个
## 进程间怎么通信
- 管道
- `系统IPC(信号量, 消息, 共享内存, 信号)`
- 套接字
## 虚拟内存置换的方式
- `FIFO`先进先出
- `LFU`最不经常访问
- `LRU`最近最少
- `LRU-K`最近最少-改进算法
## 多线程，线程同步的几种方式
- 多线程同步: 互斥锁, 自旋锁, 条件锁, 读写锁, 
- 线程通信: 锁机制, 信号量(有名和无名)机制, 信号
- 多进程同步: `信号量`, `管程`, `消息传递`
## 互斥锁(mutex)机制，以及互斥锁和读写锁的区别

## 进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞

## `A* a = new A; a->i = 10`;在内核中的内存分配上发生了什么？

## 给你一个类，里面有static，virtual，之类的，说一说这个类的内存分布

## 软链接和硬链接区别
- 软连接
- 硬链接
## 什么是大端小端以及如何判断大端小端
- 概念
- 判断
## 静态变量什么时候初始化
- 位置
- 初始化:`c`, `c++`
## 用户态和内核态区别

## 如何设计`server`，使得能够接收多个客户端的请求

## 死循环+来连接时新建线程的方法效率有点低，怎么改进？

## 怎么唤醒被阻塞的`socket`线程？

## 怎样确定当前线程是繁忙还是阻塞？
- ps
## 请问就绪状态的进程在等待什么？
- 进程就绪分为两种情况: 静止就绪和活动就绪
## 多线程的同步，锁的机制
- 在多线程的情况下,使用互斥量实现实现对共享内存的互斥访问
- 在访问共享资源之前需要先申请互斥量, 如果申请失败会阻塞
- 如果申请成功则, 则在使用完共享资源之后释放互斥量
- 释放互斥量,会导致原先因为申请互斥锁失败的线程重新唤醒,若果有多个线程因为互斥量被阻塞,则第一个唤醒的线程申请互斥锁,其他线程继续阻塞,这种情况下就完成了只有一个线程访问共享资源
## 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？
- 自旋锁: 
- 自旋锁的实现主要有三种方式:
	- 单核不可抢占内核, 自旋锁为空,即什么都不干
	- 单核可抢占内核, 除了设置`禁止内核抢占`之外,什么都不干
	- 多核可抢占内核, 设置`禁止内核抢占`+`自旋`
- **注意:** 禁止内核抢占只是关闭“可抢占标志”，而不是禁止进程切换。显式使用`schedule`或进程阻塞(此也会导致调用`schedule)`时，还是会发生进程调度的。
- 所以单核可抢占模式下,就会发生两个进程都获得了临界资源的情况:
	- 即 某一个进程获得了自旋锁,然后阻塞掉了,另一个进程继续获取自选锁,因为资源所为空嘛,所以依旧是可能的
---
- 自旋锁应发死锁的情况
	- 阻塞
	- 函数调用
	- 中断
## `windows`消息机制知道吗，请说一说
- windows消息是:系统发送给应用程序的通告
- windows都是事件驱动的, 事件驱动围绕消息的产生和处理展开, 应用程序要实现的功能由消息来触发，并靠对消息的响应和处理来完成。消息提供了系统和应用程序,应用程序和应用程序之间的通信手段. 
- windows维护了两个队列: 系统消息队列和应用程序消息队列
- windows监控所有的输入设备,当发生输入时,先将输入放入到系统消息中,然后复制到应用程序消息队列中, 应用程序消息队列通过消息循环从应用程序消息队列中检索每一个消息并发送给相应的窗口函数
- 
- 消息循环是windows应用程序存在的根本, 引用程序通过消息循环获取各种消息, 并通过相应的窗口函数对消息加以处理;这是这个消息循环使得windows应用程序可以响应各种操作, 所以消息循环往往是windows应用程序的核心
## C++的锁你知道几种?
- 互斥锁
- 自旋锁
- 条件锁
- 读写锁
## 说一说你用到的锁

## 请你说一说死锁产生的必要条件？
- 条件:`四个`
- 解决方案: `三个`
## 内存溢出和内存泄漏
- 内存溢出:
- 原因
## 进程和线程的区别，你都使用什么线程模型
- 进程的概念: 
- 线程的概念
- 常见的线程模型
	- Future模型
	- fork && join模型
	- actor模型
	- 生产者消费者模型
	- master-worker模型
## 请你来说一说协程
- 协程
- 和线程的区别
## 系统调用是什么，你用过哪些系统调用	
## 请你来手写一下`fork`调用示例
## 用户态到内核态的转化原理
- 转换场景: 异常, 外围设备中断, 系统调用
- 切换过程: 切换内核栈, 保存线程, 调转至中断处理函数
## 源码到可执行文件的过程
- 预编译: 
- 编译: 
- 汇编: 
- 链接: `静态链接`, `动态链接`
## 微内核与宏内核
- 微内核: `概述`, `优点`, `缺点`
- 宏内核: `概述`, `优点`, `缺点`

## 僵尸进程
- `linux`的机制问题
- 此机制导致的三种情况:
	- 正常情况
	- 收养机制
	- 僵尸进程
- 僵尸进程
	- 危害
	- 解决
		- 外部解决
		- 内部解决: `信号处理函数`, `fork两次(注意两次fork法存在一些问题!)`
## 请问GDB调试用过吗，什么是条件断点
- GDB作用
- 如果没有GDB
- 有了只有可以进行的操作
## 介绍一下5种IO模型
- 阻塞非阻塞, IO复用
- 信号驱动IO
- 异步IO
## 异步编程的事件循环
- 事件驱动的程序或则异步编程的程序一般都有一个主循环, 或则称为事件循环
- 事件循环一般有两个任务: 事件检测和事件处理
- 事件循环会不停的检测是否有事件发生, 如果检测到有事件发生, 则执行该事件绑定的方法,待该处理完毕之后再继续检测事件的发生.
- 它有几个特点:
	- 它只是进程中的一个线程
	- 如果发生的事件绑定了多个方法, 它待素有的方法都执行完毕之后才会继续进行检测新事件
	- 在执行事件绑定的方法期间, 不会检测新事件的发生.
## 操作系统为什么要分内核态和用户态
- 内核态以及用户态
- 系统调用
## 为什么要有`page cache`，操作系统怎么设计的`page cache`
- 目的:减少`磁盘IO`
- 设计:两个数据结构:`redix tree`, 双向链表
## `server`端监听端口，但还没有客户端连接进来，此时进程处于什么状态？
- 对于阻塞IO,进程阻塞
- 对于IO复用,进程循环等待, 所有的监听套接字
- 对于异步IO, 进程完成自己的逻辑
## 怎么实现线程池
- 线程池主要包括三个主要部分: 生产者, 消费者, 资源队列
- 生产者
- 消费者
- 资源队列
## `Linux`下怎么得到一个文件的`100`到`200`行
- `head -n 200 | tail -n 100 filename`
- `sed -n '100,200p' filename`
- `awk '{if(NR>=100 && NR<=200){print $0}}'`
## 请你来说一下`awk`的使用
- `awk`是一个文本分析工具, 它将文件逐行读取, 然后使用分隔符进行切片, 再对切开的部分进行各种处理
- 使用方法: `awk -F ':' '{pattern + action }' filename` 
	- `-F`:后面跟着分隔符, 使用`'[xxx]'`可以设置多种分割符
	- `pattern`: 支持正则表达式
	- `action`:`BEGIN`, `END`, `print`, `printf` 以及类似`c语言`的逻辑操作
- 内置变量:
	- `ARGV/ARGC`:命令行参数列表/数量
	- `ENVIRON`: 系统变量
	- `FILENAME`: 文件名
	- `FNR`: 浏览文件的数量
	- `NR`: 行数
	- `FS`: 列数(切片数)
	- `$0`: 行
	- `${1...n}`: 第几个列(切片)

## `linux`内核中的`Timer`定时器机制
- 新版本的`linux`中包括两种时钟:`低精度时钟`和`高精度时钟`
- `低精度时钟`
	- 工作方式:
		- 初始化系统时间
		- 设置时钟事件设备, 产生`tick`中断
		- `tick`中断触发中断处理函数,更新系统时间, 检测时间轮, 处理超时事件
	- 特点:
		- 使用多级时间轮实现和维护所有定时事件, `tick`节拍引起周期性的检测时间轮, 所以只支持ms级定时
- `高精度时钟`与低精度时钟的区别:`定时器的管理`, `定时器的实现`
	- `高精度时钟`工作方式:
		- 基于红黑树和事件触发的定时器管理
		- 模拟tick节拍
		- 对时间硬件设备的封装
	
